// Assets/FESGAS/Editor/DataMirror/DataMirrorGenerator.cs
#if UNITY_EDITOR
using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Reflection;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace FarEmerald.PlayForge.Extended.Editor
{
    static class DataMirrorGenerator
    {
        // const string OutputFolder = "Assets/FESGAS/Data/FESGAS_Generated/DataMirrors";
        const string OutputFolder = "Assets/PlayForge/Runtime/Forge/MirrorGeneration/Partials";

        // [InitializeOnLoadMethod]
        static void AutoGenerateOnRecompile()
        {
            // Optional: comment this out if you only want the menu command.
            GenerateAll();
        }

        [MenuItem("Tools/PlayForge/More/Regenerate Data Mirrors", false, 124)]
        public static void GenerateAll()
        {
            Directory.CreateDirectory(OutputFolder);

            var targets = TypeCache.GetTypesWithAttribute<MirrorFromAttribute>();
            foreach (var target in targets.OrderBy(t => t.FullName))
            {
                try { GenerateForTarget(target); }
                catch (Exception ex)
                {
                    Debug.LogError($"[FESGAS Mirror] Failed for {target.FullName}: {ex}");
                }
            }

            AssetDatabase.Refresh();
            Debug.Log("[FESGAS Mirror] Regenerated data mirrors.");
        }

        static void GenerateForTarget(Type target)
        {
            var attr = target.GetCustomAttribute<MirrorFromAttribute>();
            if (attr?.SourceType == null) return;
            var srcType = attr.SourceType;

            // Collect substitutions
            var ignores = target.GetCustomAttributes<MirrorIgnoreAttribute>().Select(a => a.FieldName).ToHashSet();
            var subs    = target.GetCustomAttributes<MirrorSubstituteAttribute>().ToList();
            var subsOpen= target.GetCustomAttributes<MirrorSubstituteOpenGenericAttribute>().ToList();

            var fields = CollectUnitySerializableFields(srcType)
                .Where(f => !ignores.Contains(f.Name))
                .ToList();

            // Build file text
            var code = EmitPartial(target, srcType, fields, subs, subsOpen);

            var path = Path.Combine(OutputFolder, $"{target.Name}.generated.cs");
            // Avoid endless recompile loops if nothing changed
            if (!File.Exists(path) || File.ReadAllText(path) != code)
            {
                File.WriteAllText(path, code, new UTF8Encoding(encoderShouldEmitUTF8Identifier: true));
            }
        }

        static IEnumerable<FieldInfo> CollectUnitySerializableFields(Type t)
        {
            const BindingFlags f = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.DeclaredOnly;
            // Walk base types to include inherited serializable fields
            for (var cur = t; cur != null && cur != typeof(object); cur = cur.BaseType)
            {
                foreach (var fi in cur.GetFields(f))
                {
                    if (fi.IsStatic || fi.IsInitOnly) continue;
                    if (fi.GetCustomAttribute<NonSerializedAttribute>() != null) continue;

                    // Mirror the Unity serializable surface: public OR [SerializeField]
                    if (fi.IsPublic || fi.GetCustomAttribute<SerializeField>() != null)
                        yield return fi;
                }
            }
        }

        static string EmitPartial(
            Type target, Type srcType, List<FieldInfo> fields,
            List<MirrorSubstituteAttribute> subs,
            List<MirrorSubstituteOpenGenericAttribute> subsOpen)
        {
            string Ns(Type t) => "FarEmerald.PlayForge.Extended";
            // string Ns(Type t) => string.IsNullOrEmpty(t.Namespace) ? null : t.Namespace;

            var sb = new StringBuilder(8 * 1024);
            sb.AppendLine("// <auto-generated> PlayForge mirror partial. Do not edit. </auto-generated>");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using UnityEngine;");

            if (Ns(target) != null) sb.AppendLine($"namespace {Ns(target)}\n{{");

            sb.AppendLine($"\tpublic partial class {target.Name}");
            sb.AppendLine("\t{");
            sb.AppendLine($"\t\t// Mirrored from: {srcType.FullName}");
            foreach (var fi in fields.OrderBy(f => f.Name, StringComparer.Ordinal))
            {
                var mirroredType = SubstituteType(fi.FieldType, subs, subsOpen);
                var typeName = CSharpTypeName(mirroredType);
                // Always public for simplicity; you can toggle to match original visibility if you prefer.
                sb.AppendLine($"\t\tpublic {typeName} {fi.Name};");
            }
            sb.AppendLine("\t}");

            if (Ns(target) != null) sb.AppendLine("}");
            return sb.ToString();
        }

        static Type SubstituteType(
            Type t,
            List<MirrorSubstituteAttribute> subs,
            List<MirrorSubstituteOpenGenericAttribute> subsOpen)
        {
            // Concrete substitution first (exact match)
            var direct = subs.FirstOrDefault(s => s.From == t);
            if (direct != null) return direct.To;

            // Open generic substitution (e.g., any UnityEngine.Object -> AssetRef<T>)
            foreach (var s in subsOpen)
            {
                if (s.SourceBase.IsAssignableFrom(t))
                {
                    if (s.OpenGenericTarget.IsGenericTypeDefinition)
                    {
                        return s.OpenGenericTarget.MakeGenericType(t);
                    }
                    return s.OpenGenericTarget;
                }
            }

            // Recurse into arrays and generics (List<T> -> List<Sub(T)>)
            if (t.IsArray)
            {
                var e = SubstituteType(t.GetElementType(), subs, subsOpen);
                return e == t.GetElementType() ? t : e.MakeArrayType();
            }

            if (t.IsGenericType)
            {
                var def = t.GetGenericTypeDefinition();
                var args = t.GetGenericArguments();
                var newArgs = args.Select(a => SubstituteType(a, subs, subsOpen)).ToArray();
                bool changed = newArgs.Where((a, i) => a != args[i]).Any();
                return changed ? def.MakeGenericType(newArgs) : t;
            }

            return t;
        }

        static string CSharpTypeName(Type t)
        {
            if (t.IsGenericParameter) return t.Name;

            if (!t.IsGenericType) return t.FullName?.Replace('+', '.') ?? t.Name;

            var def = t.GetGenericTypeDefinition();
            var name = def.FullName!;
            name = name.Substring(0, name.IndexOf('`')).Replace('+', '.');
            var args = string.Join(", ", t.GetGenericArguments().Select(CSharpTypeName));
            return $"{name}<{args}>";
        }
    }
}
#endif
